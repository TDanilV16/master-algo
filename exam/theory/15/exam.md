# Дерево отрезков

Дерево отрезков -- структура данных, которая позволяет эффективно (O(log n)) реализовать операции следующего вида:

- нахождение суммы/минимума элементов массива в заданном отрезке a[l..r]
- изменение элементов массива (одного или на подотрезке)

Деревья отрезков потребляют линейный объем памяти. Стандартному дереву отрезков потребуется порядка 4*n элементов памяти
для работы с массивом размера n

## Описание дерева отрезков в базовом варианте

Рассмотрим дерево отрезков для сумм.

- Есть массив a[0...n-1]
- Должны уметь находить сумму с l-го по r-ый
- Должны уметь обрабатывать присвоение a[i] = x.

## Структура дерева отрезков

Посчитаем сумму всего массива и сохраним где-нибудь. Посчитаем сумму на половинках массива и тд, пока текущий отрезок не
будет длины = 1.

Можно говорить, что отрезки, на которых мы посчитали сумму, образуют дерево. Дерево имеет линейный размер. Содержит
менее 2n вершин (логично).

Высота дерева есть величина O(log n)

## Построение

Процесс построения дерева отрезков по заданному массиву a можно делать эффективно следующим образом, снизу вверх:

- запишем значения a[i] в соответствующие листья дерева
- на основе этих значений посчитаем значения для вершин следующего уровня (сумма)
- проделываем предыдущий шаг рекурсивно

Таким образом, построение за O(n)

## Запрос суммы

На вход поступают два числа l, r, мы должны за время O(log n) посчитать сумму чисел на отрезке.
Спускаемся сверху вниз по построенному дереву отрезков. Изначально мы встаем в корень дерева отрезков.
В какие из 2 сыновей попадает отрезок [l...r]? Возможны два варианта:

- отрезок [l..r] попадает только в одного сына корня. Просто перейдем в того сына, в которого попадат орезок и применим
  алгоритм к текущей вершине
- кроме как сначала в левого сына и посчитать ответ на нем, а затем перейти в правого сына, посчитать ответ на нем и
  прибавить к нашему ответу. Иными словами: если левый сын представляет отрезок [l1..r1], а правый сын
  отрезок [l2..r2] (заметим, что l2 = r1 + 1), то мы перейдем в левого сына с запросом [l..r1], а в правого с
  запросом [l2..r]

Обработка запроса -- рекурсивная функция, которая всякий раз вызывает себя либо от левого сына, либо от правого (не
изменяя границы запроса в обоих случаях), либо от обоих сразу (при этом деля наш запрос на два соответствующих
подзапроса).
Однако, рекурсивные запросы мы будем выполнять не всегда: если границы отрезка совпали с текущим запросом, то просто
вернем вычисленное значение в вершине дерева отрезков.

Вычисление запроса представляет собой спуск по дереву отрезков, который распространяется по всем нужным ветвям дерева.

## Асимптотика

Посмотрим на каждом уровне дерева отрезков, сколько максимум отрезков могла посетить рекурсивная функция при обработке
запроса. Утверждается, что таких отрезков не более 4. Тогда, учитывая оценку O(log n) для высоты дерева, мы и получаем
нужную асимптотику времени работы алгоритма.

Докажем, что оценка о четырех отрезках верна.

На нулевом уровне дерева запросом затрагивается единственная вершина -- корень дерева. На первом уровне рекурсивный
вызов в худшем случае разбивается на два рекурсивных вызова, но важно то, что запросы в этих двух вызовах будут
соседствовать. Т.е l'' запроса во втором рекурсивном вызове это r'+1 первого рекурсивного вызова.

Отсюда следует, что на следующем уровне каждый из этих двух вызовов мог породить еще по 2 рекурсивных вызова, но в таком
случае половина этих запросов отработает нерекурсивно, взяв нужное значение из вершины дерева отрезков. Таким образом,
всякий раз у нас будет не более 2 параллельно работающих ветвей рекурсии (можно сказать, что одна ветвь приближается к
левой границе запроса, а вторая ветвь -- к правой), а всего число затронутых отрезков не могло превысить высоты дерева
отрезков, умноженной на четыре, т.е оно есть число O(log n).

Можно нарисовать ДО для массива 1-10 и запросить сумму по индексам 1-8. У нас будет 2 вызова рекурсии для детей корня и
по 4 вызова рекурсии от обоих детей. У каждого ребенка по факту из-за соседства границ только по 1 рекурсивному вызову (
другой вернется сразу из вершины).

Входной отрезок [l..r] разбивается на несколько подотрезков, ответ на каждом из которых уже подсчитан и сохранен в
дереве. Если делать это разбиение правильным образом, то благодаря структуре дерева отрезков число необходимых
подотрезков всегде будет O(4 * log n)

## Запрос обновления

Запрос обновления получает на вход индекс i и значение x, и перестраивает дерево отрезков таким образом, чтобы оно
соответствовало новому значению a[i] = x. Этот запрос должен выполняться за время O(log n)

a[i] участвует только в относительно небольшом числе вершин дерева отрезках, а именно в O(log n) вершинах -- по одной с
каждого уровня

Тогда понятно, что запрос обновления можно реализовать как рекурсивную функцию: ей передается текущая вершина дерева
отрезков, и эта функция выполняет рекурсивный вызов от одного из двух своих сыновей (от того, который содержит позицию i
в своем отрезке), а после этого пересчитывает значение суммы в текущей вершине точно таким же образом, как мы это делали
при построении дерева отрезков.

## Реализация

### build

Основной трюк: пусть корень дерева имеет номер 1, тогда левый сын это 2, правый сын это 3.
Если вершина имеет номер i, то левый сын это 2i, а правый сын это 2i+1

Стоит отметить, что размер массива при такой нумерации надо ставить 4n. Дело в том, что такая нумерация работает не
идеально, когда n не является степенью двойки. Тогда появляются пропущенные номера, которым не соответствуют никакие
вершины дерева.

Дерево храним в массиве t. t [4n]int

Процедура построения дерева отрезков по a []int выглядит так:
- рекурсивная функция
- передаем массив a и номер v текущей вершины дерева и границы tl, tr отрезка, соответствующие текущей вершине дерева.
- вызываем функцию из основной программы с параметрами v=1, tl=0, tr=n-1

### sum

- рекурсивная функция
- v, tl, tr, l, r -- номер вершины, границы отрезка для вершины и границы отрезка из запроса
- вызываем функцию из основной программы с параметрами v=1, tl=0, tr=n-1, l=l, r=r

### update

- рекурсивная функция
- v, pos newValue -- вершина дерева, позиция, на которой меняем элемент и новый элемент соответственно

# Системы непересекающихся множеств. Эвристики по весу, по рангу, сжатия путей.

## DSU

[dsu с доказательством](http://e-maxx.ru/algo/dsu)

### Теория

Эта структура данных предоставляет следующие возможности. Изначально имеется несколько элементов, каждый из которых
находится в отдельном (своем собственном) множестве. За одну операцию можно объединить два каких-либо множества, а также
можно запросить, в каком множестве сейчас находится указанный элемент

- `make_set(x)` -- добавляет новый элемент x, помещая его в новое множество
- `union_sets(x, y)` -- объединяет два указанных множества (множество, в котором лежит x и множество, в котором лежит y)
- `find_set(x)` -- возвращает, в каком множестве находится указанный элемент x. На самом деле при этом возвращается один
  из элементов множества (называемый лидером или представителем). Представитель выбирается в каждом множестве самой
  структурой данных и может изменяться после вызова union_sets

DSU позволяет делать каждую из этих операций почти за O(1) в среднем.

*Также одна из реализаций позволяет добиться асимптотики O(log n) в среднем, при m >= n; а при m >> n, в среднем O(1)

### Построение эффективной структуры данных

Множества элементов мы будем хранить в виде деревьев: одно дерево соответствует одному множеству. Корень дерева -- лидер

При реализации это означает, что мы заводим массив `parent`, в котором для каждого элемента мы храним ссылку на его
предка в дереве. Для корней деревьев будем считать, что их предок -- они сами.

#### Наивная реализация

- Вся информация о множестве элементов хранится в `parent []int`
- `make_set(x)` -- просто создаем дерево с корнем в вершине x и отмечаем, что ее предок -- это она сама
- `union_sets(x, y)` -- сначала найдем лидеров множеств. Если лидеры совпали, то ничего делать не нужно. В противном
  случае, указываем, что лидер вершины x = a (или наоборот) -- тем самым присоединив одно дерево к другому
- `find_set(x)` -- поднимаемся по предкам от вершины v, пока не дойдем до корня (пока ссылка не ведет на саму себя).

Реализация неэффективна. Дерево может выродиться в цепочку, в результате `find_set` работает за O(n)

#### Эвристика сжатия путей

После вызова `find_set` мы получаем искомого лидера р, то запомним, что у вершины v и всех пройденных по пути вершин
именно такой лидер.

Таким образом, у массива предков смысл меняется: это сжатый массив предков, т.е для каждой вершины там может храниться
не непосредственный предок, а лидер (предок предка предка ...)

С другой стороны, нельзя сделать, чтобы эти указатели parent всегда указывали на лидера: иначе при `union_sets` пришлось
бы обновлять лидеров у O(n) элементов.

Таким образом, к массиву parent следует относиться как к массиву предков, возможно, частично сжатому.

##### Оценка асимптотики при применении эвристики сжатия путей

Покажем, что это позволяет достичь O(log n) на один запрос в среднем

Заметим, что, `union_sets` представляет из себя 2 вызова `find_set` и еще O(1) операций, то можно сосредоточиться в
доказательстве на оценку работы O(m) операций `find_set`

Назовем весом w[v] вершины v число потомков этой вершины (включая ее саму). Веса верщин, очевидно, могут только
увеличиваться в процессе работы алгоритма.

Назовем размахом ребра (a, b) разность весов концов этого ребра |w[a] - w[b]|. Можно заметить, что размах какого-либо
фиксированного ребра (a, b) может только увеличиваться в процессе работы алгоритма.

Разобъем ребра на классы: ребро имеет класс k, если его размах из отрезка [2^k; 2^k+1 - 1]. Класс ребра -- это число от
0 до log n.

Зафиксируем теперь произвольную вершину x и будем следить, как меняется ребро ее предка. Его сначала нет, потом оно
может появиться, затем может меняться при сжатии путей в процессе вызовов `find_path`. Все случаи, кроме последнего
делаются за O(1)

Рассмотрим работу некоторого вызова `find_set`: он проходит в дереве вдоль некоторого пути, стирая все ребра этого пути
и перенаправляя их в лидера.

Рассмотрим этот путь и исключим из рассмотрения последнее ребро каждого класса (т.е не более чем по одному ребру из
класса). Тем самым мы исключили O(log n) ребер из каждого запроса

Рассмотрим все остальные ребра этого пути. Для каждого ребра, если оно имеет класс k, получается, что в этом пути есть
еще одно ребро класса k (иначе мы были бы обязаны исключить теккущее ребро, как единственного представителя класса k).

Таким образом, после сжатия пути это ребро заменится на ребро класса как минимум k+1. Учитывая, что уменьшаться вес
ребра не может, мы получаем, что для каждой вершины, затронутой запросом `find_path`, ребро в ее предка либо было
исключено, либо строго увеличило свой класс.

Отсюда получаем асимптотику m запросов O((n + m) log n). При m >= n, это означает логарифмическое время работы на один
запрос в
среднем.

#### Эвристика объединения по рангу

Эвристика заключается в небольшой модификации работы `union_sets`. Теперь мы объединяем деревья по рангу

Объединяем деревья так: присоединяем дерево с меньшим рангом к дереву с большим рангом.

*ранг -- количество вершин в дереве или глубина дерева, сути не меняет.

##### Оценка асимптотики при применении ранговой эвристики

Покажем, что применении только ранговой эвристики, на один запрос нужно будет в среднем O(log n)

###### Ранговая эвристика по глубине дереве

Покажем, если ранг дерева равен k, то это дерево содержит минимум 2^k вершин (отсюда следует, что ранг и глубина
дерева = O(log n)). По мат индукции

- k = 0 -- очевидно
- При сжатии путей глубина может только уменьшиться. Ранге дерева увеличивается с k - 1 до k, когда к нему прибавляют
  дерево ранга k - 1. Применяем к обоим деревьям размера k - 1 предположение индукции, получаем, что новое дерево ранга
  k будет
  иметь как минимум 2^k вершин.

###### Ранговая эвристика по размеру дерева

Покажем, что если размер дерева равен k, то его высота не более чем округленный вниз log k. По индукции

- k = 1 -- очевидно верно (0 для дерева из одного узла и 1 для дерева с одним корнем и листьями)
- Пусть теперь объединяем деревья k1 и k2. По предположению индукции высоты не более log k1 log k2 округлить вниз.
- Не теряя общности, считаем k1 >= k2. Поэтому после объединения глубина получившегося дерева из k1 + k2 равна
  h = max(log k1, 1 + log k2).

Чтобы завершить доказательство, надо показать что

h <= log (k1 + k2) округлить вниз

2^h = max(2 ^ log k1, 2 ^ log 2k2) <= 2 ^ log(k1 + k2)

Неравенство очевидно, поскольку k1 <= k1 + k2 && 2k2 <= k1 + k2

#### Объединение эвристик

Достигает почти константного времени работы. Доказательство жесткое.

Окончательный результат таков: при совместном применении эвристик сжатия путей и объединени по рангу время работы на
один запрос O(a(n)) в среднем, где a(n) -- обратная функция Аккермана, которая растет очень медленно. настолько
медленно, что для всех разумных ограничений n, она не превосходит 4 (n < 10^600)

Именно поэтому говорят почти константное время.

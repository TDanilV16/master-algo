# Топологическая сортировка. Компоненты сильной связности. Граф конденсации.

## Топологическая сортировка с помощью поиска в глубину

### Определение

[dfs](https://neerc.ifmo.ru/wiki/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83_%D0%B4%D0%BB%D1%8F_%D1%82%D0%BE%D0%BF%D0%BE%D0%BB%D0%BE%D0%B3%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B9_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)

Топологическая сортировка ориентированного ациклического графа G = (V, E) представляет собой упорядочивание вершин такми
образом, что для любого ребра (u, v) номер вершины u меньше номера вершины v.

Ациклический граф -- граф, который не срдержит замкнутых петель или циклов, то есть из любой точки нельзя вернуться в
нее же, двигаясь только по направлению ребер.

### Применение

- При обработке исходного кода программы в некоторых компиляторах и IDE, где строится граф зависимостей между
  сущностями, после чего они инициализируются в нужном порядке, либо выдается ошибка о циклической зависимости
- Можно найти гамильтонов путь в ациклическом графе

### Алгоритм

[цвет вершин в dfs](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%B1%D1%85%D0%BE%D0%B4_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83,_%D1%86%D0%B2%D0%B5%D1%82%D0%B0_%D0%B2%D0%B5%D1%80%D1%88%D0%B8%D0%BD)
[top sort](http://e-maxx.ru/algo/topological_sort)
[habr](https://habr.com/ru/articles/100953/)

Для решения воспользуемся поиском в глубину.

Предположим, граф ацикличен, т.е решение существует. Что делает обход в глубину? При запуске из какой-то вершины v он
пытается запуститься вдоль всех ребер, исходящих из v. Вдоль тех ребер, концы которых уже были посещены ранее, он не
проходит, а вдоль всех остальных -- проходит и вызывает себя от их концов

Таким образом, к моменту выхода из dfs(v) все вершины, достижимые из v по одному ребру, так и по пути -- все эти вершины
уже посещены обходом. Следовательно, если мы будем в момент выхода из dfs(v) добавлять нашу вершину в начало некоего
списка, то в конце концов в этом списке получится топологическая сортировка.

Эти объяснения можно представить с помощью понятия "времени выхода" или "когда покрасили в черный" в обходе в глубину.
Время выхода для каждой вершины v -- это момент времени, в который закончил работать вызов dfs(v) обхода в глубину. (
Время выхода можно нумеровать от 1 до n). Можно это рассматривать как момент, когда мы все вершины пометили
серым/обнаружили. При обходе в глубину время выхода из какой-либо вершины v всегда больше, чем
время выхода из всех вершин, достижимых из нее (т.к они были посещены либо до вызова dfs(v) либо во время него). Таким
образом, искомая топологическая сортировка -- сортировка в порядке убывания времен выхода

### Время работы алгоритма

Время работы алгоритма равно времени поиска в глубину и равно O(n + m)

## Компоненты сильной связности

### Определения

1. Орграф сильно связен, если из любой его вершины в любую другу есть путь.
2. Компонента сильной связности -- максимальный сильно связный подграф

### Алгоритм

Алгоритм Косараю

[dfs для поиска компонент сильной связности](https://neerc.ifmo.ru/wiki/index.php?title=%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B0_%D0%B2_%D0%B3%D0%BB%D1%83%D0%B1%D0%B8%D0%BD%D1%83_%D0%B4%D0%BB%D1%8F_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82_%D1%81%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
[dfs для поиска компонент сильной связности (реализация)](http://e-maxx.ru/algo/strong_connected_components)

Компоненты сильной связности в графе G можно найти с помощью поиска в глубину в 2 этапа:

1. Выполнить в G поиск в глубину и найти время окончания обработки вершины u (в каком порядке вершины стали черными).
   Этот массив order
2. Транспонировать граф G (и построить его). Запустить серию обходов в глубину этого графа в порядке, определяемом
   списком order (а именно в обратном порядке, т.е в порядке убывания времени выхода). Каждое очередное множество
   вершин, достигнутое в результате очередного запуска обхода, и будет очередной компонентой связности

### Доказательство корректности

TODO

### Асимптотика

O(n + m), поскольку это всего лишь 2 обхода в глубину.

## Граф конденсации
# Алгоритм Дейкстры.

## Постановка задачи

Дан ориентированный или неориентированный взвешенный граф с n вершин и m ребрами. Веса всех ребер неотрицательны.
Указана некоторая стартовая точка s. Требуется найти длины кратчайших путей из вершины s во все остальные вершины, а
также предоставить способ вывода кратчайших путей.

## Алгоритм

Заведем массив d, в котором для каждой вершины будем хранить текущую длину d[v] кратчайшего пути из s в v. d[s] = 0, для
всех остальных вершин эта длина равна бесконечности. (обычно в качестве бесконечности выбирают просто достаточно большое
число, заведомо больше возможной длины пути).

Кроме того, для каждой вершины будем хранить, помечена она еще или нет. marked []bool.

Сам алгоритм состоит из n итераций. На очередной итерации выбирается вершина v с наименьшей величиной d[v] среди еще не
помеченных.

d[v] = min d[p], p: !u[p]

Выбранная таким образом вершина отмечается помеченной. Далее, на текущей итерации, из вершины v производятся релаксации:
просматриваются все ребра (v, to), исходящие из вершины v, и для каждой такой вершины to алгоритм пытается улучшить
значение d[to].

d[to] = min(d[to], d[v] + len).

На этом текущая итерация прекращается, алгоритм переходит к следующей. При этом в конце концов после n итераций все
вершины графа станут помеченными, и алгоритм свою работу прекращает. Утверждается, что найденные значения d[v] и есть
искомые длины кратчайших путей из s в v.

## Восстановление путей

Для этого достаточно использовать массив предков: массив p []int, в котором для каждой вершины v хранится номер вершины,
являющейся предпоследней в кратчайшем пути до вершины v. Если мы будем обладать этим массивом предков, то кратчайший
путь можно будет восстановить по нему, просто каждый раз беря предка от текущей вершины, помы мы не придем в стартовую
вершину s, но записанный в обратном порядке.

После каждой успешной релаксации мы записываем, что предком вершины to является вершина v:

p[to] = v.

## Реализация

n итераций, на каждой из которых выбирается непомеченная вершина с наименьшей величиной d[v], эта вершина помечается, и
затем просматриваются все ребра, исходящие из этой вершины, и вдоль каждого ребра делается попытка улучшить значение d[]
на другом конце ребра

Время работы алгоритма складывается:

- n раз поиск вершины с наименьшей величиной d[v] среди всех непомеченных O(n) вершин
- m раз производится попытка релаксации
 
O(n^2 + m)
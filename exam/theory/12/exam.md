# Хеш Карпа-Рабина. Поиск подстроки в строке с его помощью и анализ вероятностей коллизий.

## Метод хэширования

Пусть дана строка s[0..n-1]. Тогда полиномиальным хэшем s называется число

h = hash(s[0..n-1]) = p^0 * s[0] + ... + p^(n-1) * s[n-1], где p == некоторое простое число, а s[i] -- код i-го символа
строки s

Проблему переполнения при вычислении хэшей довольно больших строк можно решить так -- считать хэши по модулю r = 2^64 (
2^32), чтобы модуль брался автоматически при переполнении типов.

Для работы алгоритма потребуется считать хэш подстроки s[i..j]. Делать это можно следуюшим образом:

hash(s[0..j]) = s[0] + p * s[1] + ... + p^(i-1) * s[i-1] + p^i * s[i] + ... + p^j * s[j]

Разобъем сумму на две части

hash(s[0..j]) = (s[0] + p * s[1] + ... + p^(i-1) * s[i-1]) + (p^i * s[i] + ... + p^j * s[j])

Из последней скобки вынесем p^i

hash(s[0..j]) = (s[0] + p * s[1] + ... + p^(i-1) * s[i-1]) + p^i * (s[i] + ... + p^(j-1-i) * s[j-1] + p^(j-i) * s[j])

Выражение в первой скобке это хэш строки s[0...i-1], а второй -- хэш подстроки s[i..j]. Таким образом,

hash(s[0..j]) = hash(s[0..i-1]) + p^i * hash(s[i..j])

Отсюда получаем формулу

hash(s[i..j]) = (1/p^i) * (hash(s[0..j]) - hash(s[0..i-1]))

Как видно из формулы, чтобы посчитать хэш для всех подстрок, начинающихся с i, нам нужно посчитать все p^i i = [0..n-1].
Это займет много памяти; но поскольку нам нужны только подстроки размером m -- мы можем подсчитать хэш подстроки
s[0..m-1], а затем пересчитывать хэши для всех i = [0..n-m] за O(1) следующим образом

hash(s[i+1..i+m-1]) = (hash(s[i..i+m-1]) - p^(m-1) * s[i]) mod r
hash(s[i+1..i+m]) = (p * hash(s[i+1..i+m-1]) + s[i+m]) mod r

hash(s[i+1..i+m]) = (p * hash(s[i..i+m-1]) - p^i * s[i] + s[i+m]) mod r

## Решение

Алгоритм начинается с подсчета hash(s[0..m-1]) и hash(p[0..m-1]), а также подсчитать p^m для ускорения ответов на запрос

Для i = [0..n-m] вычисляется hash(s[i..i+m-1]) и сравнивается с hash(p[0..m-1]). Если они оказались равны, то образец p
скорее всего содержится в строке s, начиная с позиции i.

## Время работы

- Изначальный подсчет хэшей выполняется за O(m)
- Каждая итерация выполняется за O(1), в цикле всего n - m + 1 итераций
- Итоговое время работы O(n+m)

